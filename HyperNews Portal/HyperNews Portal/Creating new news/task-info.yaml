type: edu
files:
- name: base.py
  visible: false
  text: |
    # -*- coding: utf-8 -*-
    import copy
    import http.cookiejar
    import json
    import os
    import re
    import urllib
    from datetime import datetime

    from hstest.django_test import DjangoTest
    from hstest.check_result import CheckResult


    class HyperNewsTest(DjangoTest):
        COMMON_LINK_PATTERN = '''<a[^>]+href=['"]([a-zA-Z\d/_]+)['"][^>]*>'''
        CSRF_PATTERN = b'<input[^>]+name="csrfmiddlewaretoken" ' \
                       b'value="(?P<csrf>\w+)"[^>]*>'
        GROUPS_FIRST_PATTERN = '<h4>.*?</h4>.*?<ul>.+?</ul>'
        GROUPS_SECOND_PATTERN = (
            '''<a[^>]+href=['"]([a-zA-Z\d/_]+)['"][^>]*>(.+?)</a>'''
        )
        H2_PATTERN = '<h2>(.+?)</h2>'
        H4_PATTERN = '<h4>(.+?)</h4>'
        PARAGRAPH_PATTERN = '<p>(.+?)</p>'
        TEXT_LINK_PATTERN = '''<a[^>]+href=['"][a-zA-Z\d/_]+['"][^>]*>(.+?)</a>'''
        cookie_jar = http.cookiejar.CookieJar()

        def __init__(self, *args, **kwargs):
            current_dir = os.path.dirname(os.path.abspath(__file__))
            self.news_file_name = 'news.json'
            os.environ['NEWS_JSON_PATH'] = os.path.join(current_dir,
                                                        self.news_file_name)
            super().__init__(*args, **kwargs)

        def __stripped_list(self, list):
            return [item.strip() for item in list]

        def __setup(self):
            self.news_data = [{
                'created': '2020-02-09 14:15:10',
                'text': 'Text of the news 1',
                'title': 'News 1',
                'link': 1
            }, {
                'created': '2020-02-10 14:15:10',
                'text': 'Text of the news 2',
                'title': 'News 2',
                'link': 2
            }, {
                'created': '2020-02-09 16:15:10',
                'text': 'Text of the news 3',
                'title': 'News 3',
                'link': 3
            }]
            with open(self.news_file_name, 'w') as f:
                json.dump(self.news_data, f)

        def check_coming_soon_page(self) -> CheckResult:
            self.__setup()
            try:
                page = self.read_page(f'http://localhost:{self.port}/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the "Coming soon" page.')

            opener = urllib.request.build_opener(
                urllib.request.HTTPCookieProcessor(self.cookie_jar))
            try:
                response = opener.open(f'http://localhost:{self.port}/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the "Coming soon" page.')

            coming_soon_text = 'Coming soon'

            # response.url for the backward compatibility
            if (coming_soon_text not in page
                    and response.url != f'http://localhost:{self.port}/news/'):
                return CheckResult.false(
                    '"Coming soon" page should contain "Coming soon" text'
                )

            return CheckResult.true()

        def check_coming_soon_page_redirect(self) -> CheckResult:
            self.__setup()

            opener = urllib.request.build_opener(
                urllib.request.HTTPCookieProcessor(self.cookie_jar))
            try:
                response = opener.open(f'http://localhost:{self.port}/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the "Coming soon" page.')

            if response.url != f'http://localhost:{self.port}/news/':
                return CheckResult.false(
                    f'"Coming soon" page should redirects '
                    f'to the http://localhost:{self.port}/news/'
                )

            return CheckResult.true()

        def check_main_header(self) -> CheckResult:
            self.__setup()
            try:
                page = self.read_page(f'http://localhost:{self.port}/news/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the main page.'
                )

            h2_headers = re.findall(self.H2_PATTERN, page, re.S)
            h2_headers = self.__stripped_list(h2_headers)
            main_header = 'Hyper news'

            if main_header not in h2_headers:
                return CheckResult.false(
                    'Main page should contain <h2> element with text "Hyper news"'
                )

            return CheckResult.true()

        def check_news_page(self) -> CheckResult:
            self.__setup()
            testing_news = self.news_data[0]
            link = testing_news['link']
            created = testing_news['created']

            try:
                page = self.read_page(f'http://localhost:{self.port}/news/{link}/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the news page.'
                )

            page_headers = re.findall(self.H2_PATTERN, page, re.S)
            page_headers = self.__stripped_list(page_headers)
            page_paragraphs = re.findall(self.PARAGRAPH_PATTERN, page, re.S)
            page_paragraphs = self.__stripped_list(page_paragraphs)
            if testing_news['title'] not in page_headers:
                return CheckResult.false(
                    'News page should contain <h2> element with the data '
                    'of the title field from json file.'
                )

            if testing_news['text'] not in page_paragraphs:
                return CheckResult.false(
                    'News page should contain <p> element with the data '
                    'of the text field from json file.'
                )

            if created not in page_paragraphs:
                return CheckResult.false(
                    'News page should contain <p> element with the data '
                    'of the created field from json file '
                    'in the format: "%Y-%m-%d %H:%M:%S".'
                )

            return CheckResult.true()

        def check_main_page_create_link(self):
            self.__setup()
            create_link = '/news/create/'

            try:
                page = self.read_page(f'http://localhost:{self.port}/news')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the main page.'
                )

            links_from_page = re.findall(self.COMMON_LINK_PATTERN, page, re.S)
            links_from_page = self.__stripped_list(links_from_page)

            if create_link not in links_from_page:
                return CheckResult.false(
                    f'Main page should contain <a> element with href {create_link}'
                )

            return CheckResult.true()

        def check_main_page(self) -> CheckResult:
            self.__setup()
            created_set = set()
            news_data = copy.deepcopy(self.news_data)
            for news in news_data:
                created_dt = datetime.strptime(news['created'],
                                               '%Y-%m-%d %H:%M:%S') \
                                     .date()
                created_set.add(created_dt)

            created_list = [x for x in created_set]
            created_list.sort(reverse=True)
            created_list_str = [x.strftime('%Y-%m-%d') for x in created_list]

            try:
                page = self.read_page(f'http://localhost:{self.port}/news/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the main page.'
                )

            h4_headers = re.findall(self.H4_PATTERN, page, re.S)
            h4_headers = self.__stripped_list(h4_headers)
            filtered_h4 = list(filter(lambda x: x in created_list_str, h4_headers))

            if filtered_h4 != created_list_str:
                return CheckResult.false(
                    'Main page should contain <h4> elements grouped by '
                    'date created and first should be fresh news.'
                )

            for news in news_data:
                created_date = datetime.strptime(news['created'],
                                                 '%Y-%m-%d %H:%M:%S') \
                    .date()
                news['created_date'] = created_date
                news['created_date_str'] = created_date.strftime('%Y-%m-%d')
                news['link'] = '/news/{}/'.format(news['link'])

            file_data = sorted(news_data, key=lambda x: x['title'])
            file_data = sorted(
                file_data, key=lambda x: x['created_date'], reverse=True)

            for news in file_data:
                news.pop('created_date')
                news.pop('created')
                news.pop('text')

            groups = re.findall(self.GROUPS_FIRST_PATTERN, page, re.S)
            news_list = [
                sorted(re.findall(self.GROUPS_SECOND_PATTERN, group, re.S),
                       key=lambda news: news[1])
                for group in groups
            ]
            response_data = []
            for news_l, h4 in zip(news_list, filtered_h4):
                for news in news_l:
                    response_data.append({
                        'created_date_str': h4,
                        'link': news[0],
                        'title': news[1].strip()
                    })

            if response_data != file_data:
                return CheckResult.false(
                    'Main page should contain <a> elements with href to news pages.'
                )


            return CheckResult.true()

        def check_creating_news(self):
            self.__setup()
            old_news_titles = [news['title'] for news in self.news_data]

            new_news = {
                'title': 'News 4',
                'text': 'Text of the news 4',
            }

            titles = (*old_news_titles, new_news['title'])

            opener = urllib.request.build_opener(
                urllib.request.HTTPCookieProcessor(self.cookie_jar))
            try:
                create_page_response = opener.open(
                    f'http://localhost:{self.port}/news/create/')
            except urllib.error.URLError:
                return CheckResult.false('Cannot connect to the create page.')

            create_page = create_page_response.read()

            csrf_options = re.findall(self.CSRF_PATTERN, create_page)
            if not csrf_options:
                return CheckResult.false(
                    'Missing csrf_token in the create page form')

            try:
                create_response = opener.open(
                    f'http://localhost:{self.port}/news/create/',
                    data=urllib.parse.urlencode({
                            'title': new_news['title'],
                        'text': new_news['text'],
                        'csrfmiddlewaretoken': csrf_options[0],
                    }).encode()
                )
            except urllib.error.URLError as err:
                if 'Forbidden' not in err.reason:
                    return CheckResult.false(
                        f'Wrong response for forbidden requests: {err.reason}')

            if create_response.url != f'http://localhost:{self.port}/news/':
                return CheckResult.false(
                    'After creating news handler should redirects to the /news/ '
                    'page')

            try:
                page = self.read_page(f'http://localhost:{self.port}/news/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the main page.'
                )

            links_from_page = re.findall(self.TEXT_LINK_PATTERN, page, re.S)
            links_from_page = self.__stripped_list(links_from_page)

            for title in titles:
                if title not in links_from_page:
                    return CheckResult.false(
                        f'After creating news main page can\'t find {title}')

            return CheckResult.true()

        def check_create_page_main_link(self):
            self.__setup()
            main_link = '/news/'

            try:
                page = self.read_page(
                    f'http://localhost:{self.port}/news/create/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the create page.'
                )

            links_from_page = re.findall(self.COMMON_LINK_PATTERN, page, re.S)
            links_from_page = self.__stripped_list(links_from_page)

            if main_link not in links_from_page:
                return CheckResult.false(
                    f'Create page should contain <a> element with href {main_link}'
                )

            return CheckResult.true()

        def check_news_page_main_link(self):
            self.__setup()
            main_link = '/news/'

            testing_news = self.news_data[0]
            link = testing_news['link']

            try:
                page = self.read_page(f'http://localhost:{self.port}/news/{link}/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the news page.'
                )

            links_from_page = re.findall(self.COMMON_LINK_PATTERN, page, re.S)
            links_from_page = self.__stripped_list(links_from_page)

            if main_link not in links_from_page:
                return CheckResult.false(
                    f'News page should contain <a> element with href {main_link}'
                )

            return CheckResult.true()

        def check_main_page_search(self):
            self.__setup()
            q = '2'
            news_data = copy.deepcopy(self.news_data)

            for news in news_data:
                created_date = datetime.strptime(news['created'],
                                                 '%Y-%m-%d %H:%M:%S') \
                    .date()
                news['created_date_str'] = created_date.strftime('%Y-%m-%d')

            all_headers = set((x['created_date_str'] for x in news_data))
            visible_headers = set((x['created_date_str'] for x in news_data
                                   if q in x['title']))
            invisible_headers = all_headers - visible_headers
            visible_titles = [x['title'] for x in news_data
                              if q in x['title']]
            invisible_titles = [x['title'] for x in news_data
                                if q not in x['title']]

            try:
                page = self.read_page(f'http://localhost:{self.port}/news/?q={q}')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the search page.'
                )

            h4_headers = re.findall(self.H4_PATTERN, page, re.S)
            h4_headers = self.__stripped_list(h4_headers)

            for header in visible_headers:
                if header not in h4_headers:
                    return CheckResult.false(
                        f'Search page should contain headers with found news'
                    )

            for header in invisible_headers:
                if header in h4_headers:
                    return CheckResult.false(
                        f'Search page should not contain headers with unfound news'
                    )

            titles = re.findall(self.TEXT_LINK_PATTERN, page, re.S)
            titles = self.__stripped_list(titles)

            for title in visible_titles:
                if title not in titles:
                    return CheckResult.false(
                        f'Search page should contain unfound news'
                    )

            for title in invisible_titles:
                if title in titles:
                    return CheckResult.false(
                        f'Search page should contain found news'
                    )

            return CheckResult.true()
  learner_created: false
- name: hstest/test_case.py
  visible: false
  text: |
    from typing import List, Dict, Any, Tuple, Callable


    class TestCase:

        def __init__(self, *, stdin='', args=None,
                     attach=None, files=None, copy_to_attach=False,
                     attach_callback=None):
            self.input: str = stdin
            self.args: List[str] = [] if args is None else args
            self.attach: Any = attach
            self.attach_callback: Callable = attach_callback
            self.files: Dict[str, str] = {} if files is None else files
            if copy_to_attach:
                self.attach = stdin

        @staticmethod
        def from_stepik(stepik_tests: List[Tuple[str, Any]]) -> List['TestCase']:
            hs_tests = []
            for test in stepik_tests:
                hs_test = TestCase()
                if type(test) in (list, tuple):
                    hs_test.input = test[0]
                    hs_test.attach = test[1]
                elif type(test) is str:
                    hs_test.input = test
                else:
                    raise ValueError("Bad test: " + str(test))
                hs_tests += [hs_test]
            return hs_tests
  learner_created: false
- name: hstest/exceptions.py
  visible: false
  text: |2

    class BadSolutionException(Exception):
        def __init__(self, message):
            self.message = message


    class SyntaxException(BadSolutionException):
        def __init__(self, message):
            super().__init__(message)


    class ExitException(BadSolutionException):
        def __init__(self, message):
            super().__init__(message)


    class UnexpectedErrorException(Exception):
        pass
  learner_created: false
- name: hstest/stage_test.py
  visible: false
  text: |
    import sys
    import runpy
    import os
    import io
    import importlib
    import signal
    import builtins
    import traceback
    from typing import List, Any, Dict
    from hstest.test_helper import *
    from hstest.test_case import TestCase
    from hstest.check_result import CheckResult
    from hstest.exceptions import *


    class StageTest:

        real_stdin = None
        real_print = None
        real_input = None
        user_output: io.StringIO = None

        @staticmethod
        def remove_kill_methods():
            os.kill = lambda *x, **y: exit(0)
            os._exit = lambda *x, **y: exit(0)
            os.killpg = lambda *x, **y: exit(0)
            signal.pthread_kill = lambda *x, **y: exit(0)
            signal.siginterrupt = lambda *x, **y: exit(0)

        @staticmethod
        def set_input(user_input: str):
            sys.stdin = io.StringIO(user_input)

        @staticmethod
        def add_input(user_input: str):
            sys.stdin: io.StringIO
            curr_position = sys.stdin.seek(0, io.SEEK_CUR)
            sys.stdin.seek(0)
            sys.stdin = io.StringIO(sys.stdin.read() + user_input)
            sys.stdin.seek(curr_position)

        @staticmethod
        def print(*args, **kwargs):
            StageTest.real_print(*args, **kwargs)
            StageTest.real_print(*args, **kwargs, file=StageTest.user_output)

        @staticmethod
        def input(arg=''):
            StageTest.print(arg, end='')
            user_input = StageTest.real_input()
            # StageTest.print()
            return user_input

        @staticmethod
        def replace_globals():
            StageTest.real_stdin = sys.stdin
            StageTest.real_print = builtins.print
            StageTest.real_input = builtins.input
            builtins.print = StageTest.print
            builtins.input = StageTest.input

        @staticmethod
        def get_print_back():
            builtins.print = StageTest.real_print
            sys.stdin = StageTest.real_stdin

        def __init__(self, module_to_test: str):
            self.remove_kill_methods()
            self.replace_globals()
            self.module_to_test = module_to_test
            self.this_test_file = __file__
            self.file_to_test = module_to_test.replace('.', os.sep) + '.py'
            self.full_file_to_test = ''
            self.tests: List[TestCase] = []

        def reset(self):
            StageTest.user_output = io.StringIO()
            top_module = self.module_to_test[:self.module_to_test.index('.')]
            for name, module in list(sys.modules.items()):
                if name.startswith(top_module):
                    importlib.reload(module)

        @staticmethod
        def create_files(files: Dict[str, str]):
            for file, content in files.items():
                with open(file, 'w') as f:
                    f.write(content)

        @staticmethod
        def delete_files(files: Dict[str, str]):
            for file in files.keys():
                if os.path.isfile(file):
                    os.remove(file)

        def run(self):
            runpy.run_module(
                self.module_to_test,
                run_name="__main__"
            )

        def test(self, test_case: TestCase) -> str:
            self.reset()
            try:
                self.create_files(test_case.files)
                sys.argv = [self.file_to_test] + test_case.args
                self.set_input(test_case.input)
                self.run()
                self.delete_files(test_case.files)
                return StageTest.user_output.getvalue()

            except SyntaxError as e:

                file = e.filename
                file = file.replace(os.sep, '.')
                file = file[file.index(self.module_to_test):-3]
                file = file.replace('.', os.sep) + '.py'

                output = f'File "{file}", line {e.lineno}\n' \
                         + e.text.strip()[: e.offset-1] + '\n' \
                         'SyntaxError: invalid syntax'

                # '`' * (e.offset - 2) + '^'

                raise SyntaxException(output)

            except (SystemExit, KeyboardInterrupt):
                raise ExitException('Tried to exit.')

        def generate(self) -> List[TestCase]:
            raise NotImplemented

        def check(self, reply: str, attach: Any) -> CheckResult:
            raise NotImplemented

        def after_all_tests(self):
            pass

        def get_stacktrace(self, hide_internals, skipped_traces=0):

            if self.full_file_to_test != '':
                common_prefix = os.path.commonpath([
                    self.full_file_to_test, self.this_test_file
                ])
            else:
                common_prefix = ''

            exc_type, exc_obj, exc_tb = sys.exc_info()

            if hide_internals and skipped_traces != 0:
                traceback_msg = 'Traceback (most recent call last):\n'
            else:
                traceback_msg = ''

            for line in traceback.TracebackException(
                    type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):
                if not hide_internals:
                    traceback_msg += line
                elif skipped_traces >= 0:
                    skipped_traces -= 1
                elif self.this_test_file not in line:
                    traceback_msg += line.replace(common_prefix + os.sep, '')

            return traceback_msg

        def run_tests(self):

            test_number = 0
            try:
                for test in self.generate():
                    test_number += 1
                    reply = self.test(test)
                    result = self.check(reply, test.attach)
                    if not result.result:
                        fail_msg = f'Wrong answer in test #{test_number}'
                        self.get_print_back()
                        failed(fail_msg + '\n\n' + result.feedback)
                        break
                passed()

            except SyntaxException as ex:
                self.get_print_back()
                failed(ex.message)

            except ExitException as ex:
                error_msg = f'Error in test #{test_number}'
                self.get_print_back()
                failed(error_msg + '\n\n' + ex.message)

            except Exception:

                exc_type, exc_obj, exc_tb = sys.exc_info()
                trace_frames = []

                user_trace_started = False
                skipped_traces = 0
                while exc_tb is not None:
                    code = exc_tb.tb_frame.f_code
                    filename = code.co_filename

                    if filename.endswith(self.file_to_test) and not user_trace_started:
                        user_trace_started = True
                        self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename

                    if user_trace_started:
                        trace_frames += [exc_tb.tb_frame.f_code]
                    else:
                        skipped_traces += 1

                    exc_tb = exc_tb.tb_next

                if not trace_frames:
                    exception_msg = (
                            f"Fatal error in test #{test_number}, " +
                            "please send the report to Hyperskill team."
                    )
                    stacktrace = self.get_stacktrace(hide_internals=False)

                else:
                    exception_msg = f'Exception in test #{test_number}'
                    stacktrace = self.get_stacktrace(
                        hide_internals=True,
                        skipped_traces=skipped_traces
                    )

                self.get_print_back()
                failed(exception_msg + '\n\n' + stacktrace)
            finally:
                self.after_all_tests()
  learner_created: false
- name: hstest/django_test.py
  visible: false
  text: |
    import os
    import shutil
    import signal
    import subprocess
    import sys
    from time import sleep
    from urllib.error import URLError, HTTPError
    from urllib.request import urlopen
    from hstest.stage_test import StageTest
    from hstest.check_result import CheckResult
    from hstest.exceptions import UnexpectedErrorException


    EMPTY_DATABASE = 'empty.sqlite3'
    TEST_DATABASE = 'db.test.sqlite3'


    class DjangoTest(StageTest):
        _kill = os.kill
        port = '0'
        tryout_ports = ['8000', '8001', '8002', '8003', '8004']
        process = None

        def run(self):
            if self.process is None:
                self.__find_free_port()
                self.__prepare_database()
                self.process = subprocess.Popen([
                    sys.executable, self.file_to_test,
                    'runserver', self.port, '--noreload',
                ])

        def __prepare_database(self):
            if os.path.exists(EMPTY_DATABASE):
                shutil.copyfile(EMPTY_DATABASE, TEST_DATABASE)
                os.environ['HYPERSKILL_TEST_DATABASE'] = TEST_DATABASE
                migrate = subprocess.Popen(
                    [sys.executable, self.file_to_test, 'migrate'],
                    stderr=subprocess.PIPE
                )
                exit_code = migrate.wait()
                if exit_code != 0:
                    raise UnexpectedErrorException(migrate.stderr.read().decode())

        def check_server(self):
            if self.port == '0':
                return CheckResult.false(
                    f'Please free one of the ports: {", ".join(self.tryout_ports)}'
                )

            for _ in range(15):
                try:
                    urlopen(f'http://localhost:{self.port}/not-existing-link-by-default')
                    return CheckResult.true()
                except URLError as err:
                    if isinstance(err, HTTPError):
                        return CheckResult.true()
                    sleep(1)
            else:
                return CheckResult.false(
                    'Cannot start the ./manage.py runserver for 15 seconds'
                )

        def __find_free_port(self):
            for port in self.tryout_ports:
                try:
                    urlopen(f'http://localhost:{port}')
                except URLError as err:
                    if isinstance(err.reason, ConnectionRefusedError):
                        self.port = port
                        break
                except ConnectionResetError:
                    pass

        def read_page(self, link: str) -> str:
            return urlopen(link).read().decode().replace('\u00a0', ' ')

        def after_all_tests(self):
            if self.process is not None:
                try:
                    self._kill(self.process.pid, signal.SIGINT)
                except ProcessLookupError:
                    pass
  learner_created: false
- name: hstest/test_helper.py
  visible: false
  text: |2

    def set_congratulation_message(message):
        """ Overrides default 'Congratulations!' message """
        print("#educational_plugin CONGRATS_MESSAGE " + message)


    def failed(message: str):
        """ Reports failure """
        lines = message.splitlines()
        print("\n#educational_plugin FAILED + " + lines[0])
        for line in lines[1:]:
            print("#educational_plugin " + line)


    def passed():
        """ Reports success """
        print("#educational_plugin test OK")
  learner_created: false
- name: hstest/check_result.py
  visible: false
  text: |
    class CheckResult:

        def __init__(self, result: bool, feedback: str):
            self.result = result
            self.feedback = feedback

        @staticmethod
        def true():
            return CheckResult(True, '')

        @staticmethod
        def false(feedback: str = ''):
            return CheckResult(False, feedback)


    def wrong(feedback: str = '') -> CheckResult:
        return CheckResult.false(feedback)


    def accept():
        return CheckResult.true()
  learner_created: false
- name: tests.py
  visible: false
  text: |
    # -*- coding: utf-8 -*-
    from hstest.test_case import TestCase

    from base import HyperNewsTest


    class HyperNewsTestRunner(HyperNewsTest):
        def generate(self):
            return [
                # 1 task
                TestCase(attach=self.check_server),
                TestCase(attach=self.check_coming_soon_page),
                # 2 task
                TestCase(attach=self.check_news_page),
                TestCase(attach=self.check_news_page_main_link),
                # 3 task
                TestCase(attach=self.check_main_header),
                TestCase(attach=self.check_main_page),
                TestCase(attach=self.check_main_page_create_link),
                # 4 task
                TestCase(attach=self.check_creating_news),
                TestCase(attach=self.check_create_page_main_link),
            ]

        def check(self, reply, attach):
            return attach()


    if __name__ == '__main__':
        HyperNewsTestRunner('hypernews.manage').run_tests()
  learner_created: false
feedback_link: https://hyperskill.org/projects/102/stages/564/implement
status: Unchecked
record: -1
